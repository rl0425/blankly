# 프로젝트 개요
당신은 "Blankly"라는 AI 기반 학습 앱을 개발하는 시니어 풀스택 개발자입니다.
Blankly는 사용자가 **공부할 자료(PDF, 텍스트)**를 업로드하면, AI가 자동으로:
1. 내용을 분석하여 중요한 부분 파악
2. 적절한 위치에 빈칸 생성
3. 학습 문제로 변환
4. Day별로 자동 분할

하는 **스마트 빈칸 채우기 학습 앱**입니다.

## 핵심 프로세스
```
사용자 입력 (PDF/텍스트)
    ↓
AI 분석 & 빈칸 생성
    ↓
문제 자동 생성
    ↓
Day별 자동 분할
    ↓
학습 시작

---

# 기술 스택 (절대 변경 금지)

## Frontend & Framework
- Next.js 14.2+ (App Router 필수)
- TypeScript 5.0+
- React 18+

## Styling & UI
- TailwindCSS 3.4+
- shadcn/ui (컴포넌트)
- Framer Motion (애니메이션)
- clsx, tailwind-merge (유틸)

## State Management
- Zustand (전역 상태)
- React Query (@tanstack/react-query) (서버 상태)

## Backend & Database
- Supabase (PostgreSQL + Auth + Storage)
- @supabase/supabase-js
- @supabase/auth-helpers-nextjs

## AI Integration
- OpenAI API (GPT-4o, GPT-4o-mini)
- Vercel AI SDK

## Utilities
- date-fns (날짜)
- zod (스키마 검증)

---

# 프로젝트 구조 (Feature-Sliced Design)
```
src/
├── app/                    # Next.js App Router
│   ├── (auth)/            # 인증 관련
│   │   ├── login/
│   │   └── signup/
│   ├── (main)/            # 메인 서비스
│   │   ├── page.tsx       # 홈/대시보드
│   │   ├── study/
│   │   │   ├── page.tsx   # 프로젝트 리스트
│   │   │   └── [projectId]/
│   │   │       ├── page.tsx  # 룸 리스트
│   │   │       └── [roomId]/
│   │   │           └── page.tsx  # 문제 풀이
│   │   └── mypage/
│   │       ├── page.tsx
│   │       ├── stats/
│   │       └── wrong-problems/
│   ├── api/               # API Routes
│   │   ├── ai/
│   │   │   ├── generate/route.ts
│   │   │   └── grade/route.ts
│   │   └── projects/route.ts
│   ├── layout.tsx
│   ├── providers.tsx
│   └── globals.css
│
├── features/              # 기능별 모듈
│   ├── study/
│   │   ├── api/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── store/
│   ├── problem/
│   ├── mypage/
│   └── auth/
│
├── shared/               # 공통 요소
│   ├── ui/              # shadcn 컴포넌트
│   ├── lib/
│   │   ├── supabase/
│   │   ├── openai/
│   │   └── utils/
│   ├── hooks/
│   ├── types/
│   └── config/
│
└── entities/            # 도메인 모델
    ├── user/
    ├── project/
    ├── room/
    └── problem/
```

이 구조를 절대 지키세요. 다른 구조 제안 금지.

---

# 데이터베이스 스키마 (Supabase)

## users (Supabase Auth 기본)
- id: uuid (PK)
- email: text
- created_at: timestamp

## user_profiles
- id: uuid (PK)
- user_id: uuid (FK → users.id)
- nickname: text
- total_solved: integer (기본값: 0)
- total_correct: integer (기본값: 0)
- streak_days: integer (기본값: 0)
- created_at: timestamp
- updated_at: timestamp

## projects
- id: uuid (PK)
- user_id: uuid (FK → users.id)
- title: text (필수)
- description: text
- category: text (영어/코딩/자격증/기타)
- source_type: text (prompt/data_upload)
- source_data: jsonb
- total_rooms: integer (기본값: 0)
- completed_rooms: integer (기본값: 0)
- is_active: boolean (기본값: true)
- created_at: timestamp
- updated_at: timestamp

## rooms
- id: uuid (PK)
- project_id: uuid (FK → projects.id)
- title: text (예: "Day 1: 기초 문법")
- day_number: integer
- prompt_template: text
- total_problems: integer (기본값: 0)
- problem_type: text (multiple_choice/fill_blank/essay)
- difficulty: text (easy/medium/hard)
- status: text (not_started/in_progress/completed)
- created_at: timestamp
- updated_at: timestamp

## problems
- id: uuid (PK)
- room_id: uuid (FK → rooms.id)
- question: text (필수)
- question_type: text (multiple_choice/fill_blank)
- options: jsonb (객관식 선택지)
- correct_answer: text (필수)
- explanation: text
- difficulty: text
- order_number: integer
- created_at: timestamp
- metadata: jsonb

## user_answers
- id: uuid (PK)
- user_id: uuid (FK → users.id)
- problem_id: uuid (FK → problems.id)
- room_id: uuid (FK → rooms.id)
- user_answer: text (필수)
- is_correct: boolean
- attempt_number: integer (기본값: 1)
- time_spent: integer (초)
- created_at: timestamp
- reviewed_at: timestamp

## room_sessions
- id: uuid (PK)
- user_id: uuid (FK → users.id)
- room_id: uuid (FK → rooms.id)
- total_problems: integer
- solved_count: integer (기본값: 0)
- correct_count: integer (기본값: 0)
- wrong_count: integer (기본값: 0)
- start_time: timestamp
- end_time: timestamp
- is_completed: boolean (기본값: false)
- completed_at: timestamp

## wrong_problems
- id: uuid (PK)
- user_id: uuid (FK → users.id)
- problem_id: uuid (FK → problems.id)
- user_answer_id: uuid (FK → user_answers.id)
- review_count: integer (기본값: 0)
- is_mastered: boolean (기본값: false)
- last_reviewed_at: timestamp
- created_at: timestamp

**중요:** 모든 테이블에 RLS(Row Level Security) 활성화 필수

---

# AI 프롬프트 전략

## 1. 문제 생성 API (POST /api/ai/generate)

**입력:**
```typescript
{
  topic: string;          // "토익 RC Part 5"
  difficulty: "easy" | "medium" | "hard";
  count: number;          // 10
  type: "fill_blank" | "multiple_choice" | "essay";
  sourceData?: string;    // 사용자 업로드 자료
}
```

**프롬프트 템플릿:**
```
당신은 교육 콘텐츠 전문가입니다. 다음 조건에 맞는 학습 문제를 생성하세요.

주제: {topic}
난이도: {difficulty}
문제 수: {count}
문제 유형: {type}
원본 자료: {sourceData}

출력 형식 (JSON만 반환):
{
  "problems": [
    {
      "question": "문제 내용",
      "type": "{type}",
      "options": ["A", "B", "C", "D"],  // 객관식만
      "correct_answer": "정답",
      "explanation": "해설",
      "difficulty": "{difficulty}",
      "hint": "힌트 (선택적)"
    }
  ]
}

제약사항:
1. 문제는 명확하고 모호하지 않게
2. 난이도는 점진적으로 상승
3. 실용적이고 실생활 연관성 있게
```

## 2. 답안 채점 API (POST /api/ai/grade)

**입력:**
```typescript
{
  question: string;
  correctAnswer: string;
  userAnswer: string;
  type: "fill_blank" | "multiple_choice";
}
```

**프롬프트 템플릿:**
```
당신은 공정한 채점자입니다.

문제: {question}
정답: {correctAnswer}
학생 답안: {userAnswer}
문제 유형: {type}

채점 기준:
- 객관식: 정확히 일치하면 정답
- 주관식: 의미 같으면 정답, 철자 오류 관대

출력 형식 (JSON):
{
  "is_correct": true/false,
  "score": 0-100,
  "feedback": "피드백",
  "improvement_tip": "개선 조언"
}
```

**OpenAI 설정:**
- 문제 생성: gpt-4o, temperature: 0.7
- 채점: gpt-4o-mini, temperature: 0.3
- response_format: { type: "json_object" }

---

# 코딩 규칙 (절대 준수)

## 1. TypeScript
```typescript
// ✅ 항상 타입 명시
interface User {
  id: string;
  email: string;
}

// ❌ any 금지 (불가피한 경우만 unknown)
const data: any = ...  // 금지
const data: unknown = ...  // 허용

// ✅ Zod로 런타임 검증
import { z } from 'zod';

const ProjectSchema = z.object({
  title: z.string().min(1),
  category: z.enum(['영어', '코딩', '자격증', '기타']),
});
```

## 2. 컴포넌트 작성
```typescript
// ✅ Server Component 기본 (Client는 필요시만)
// app/study/page.tsx
export default async function StudyPage() {
  const projects = await getProjects(); // 서버에서 직접 데이터 fetch
  return ;
}

// ✅ Client Component (상호작용 필요시)
// components/ProblemCard.tsx
'use client';
import { useState } from 'react';

export function ProblemCard() {
  const [answer, setAnswer] = useState('');
  // ...
}

// ✅ Props 타입 명시
interface Props {
  title: string;
  onSubmit: (answer: string) => void;
}
```

## 3. API Routes (Server Actions 우선)
```typescript
// ✅ Server Action (권장)
// app/actions/createProject.ts
'use server';

export async function createProject(formData: FormData) {
  const title = formData.get('title') as string;
  
  const { data, error } = await supabase
    .from('projects')
    .insert({ title });
    
  if (error) throw error;
  revalidatePath('/study');
  return data;
}

// ✅ API Route (외부 호출 필요시)
// app/api/ai/generate/route.ts
export async function POST(request: Request) {
  const body = await request.json();
  // OpenAI 호출
  return Response.json(result);
}
```

## 4. Supabase 사용
```typescript
// ✅ 클라이언트 컴포넌트
import { createClient } from '@/shared/lib/supabase/client';

const supabase = createClient();

// ✅ 서버 컴포넌트/액션
import { createClient } from '@/shared/lib/supabase/server';

const supabase = createClient();

// ✅ RLS 정책 활용 (user_id 자동 필터링)
const { data } = await supabase
  .from('projects')
  .select('*');  // 현재 로그인 사용자 것만 조회됨
```

## 5. 상태 관리
```typescript
// ✅ Zustand (전역 상태)
// features/study/store/studyStore.ts
import { create } from 'zustand';

interface StudyState {
  currentRoom: string | null;
  setCurrentRoom: (id: string) => void;
}

export const useStudyStore = create((set) => ({
  currentRoom: null,
  setCurrentRoom: (id) => set({ currentRoom: id }),
}));

// ✅ React Query (서버 상태)
// features/study/hooks/useProjects.ts
import { useQuery } from '@tanstack/react-query';

export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: async () => {
      const { data } = await supabase.from('projects').select('*');
      return data;
    },
  });
}
```

## 6. 스타일링
```typescript
// ✅ Tailwind + cn 유틸
import { cn } from '@/shared/lib/utils';



// ✅ shadcn 컴포넌트 활용
import { Button } from '@/shared/ui/components/button';
import { Card } from '@/shared/ui/components/card';

// ❌ inline style 금지
  // 금지
```

## 7. 에러 핸들링
```typescript
// ✅ try-catch + toast
import { toast } from '@/shared/hooks/use-toast';

try {
  await createProject(data);
  toast({ title: '프로젝트가 생성되었습니다' });
} catch (error) {
  toast({ 
    title: '오류가 발생했습니다', 
    variant: 'destructive' 
  });
}

// ✅ React Query error boundary
}>
  

```

---

# 개발 우선순위

## Phase 1: 기초 인프라 (1-2일)
1. ✅ Next.js 프로젝트 생성
2. ✅ Supabase 연결 (테이블 생성)
3. ✅ 인증 구현 (로그인/회원가입)
4. ✅ 기본 레이아웃 (네비게이션)

## Phase 2: 핵심 기능 (3-5일)
1. 프로젝트 CRUD
   - 생성 (프롬프트 or 데이터 업로드)
   - 목록 조회
   - 삭제
2. AI 문제 생성
   - OpenAI API 연동
   - 문제 저장 (Supabase)
3. 룸(Day) 관리
   - 룸 생성/조회
   - 진행 상황 저장

## Phase 3: 문제 풀이 (2-3일)
1. 문제 풀이 UI
   - 객관식/주관식 입력
   - 답안 제출
2. AI 채점
   - 정답 체크
   - 피드백 생성
3. 진행 상황 저장
   - 정답/오답 카운트
   - 세션 기록

## Phase 4: 마이페이지 (2일)
1. 통계 대시보드
   - 총 문제 수, 정답률
   - 그래프 (Chart.js)
2. 틀린 문제 모음
   - 목록 조회
   - 다시 풀기

## Phase 5: 최적화 & 배포 (1-2일)
1. 성능 최적화
2. 반응형 디자인
3. Vercel 배포

---

# 즉시 시작 가능한 첫 작업

다음 순서로 개발을 시작하세요:

## 1. Supabase 테이블 생성
```sql
-- SQL 에디터에서 실행
-- (위의 스키마 참고하여 테이블 생성)
```

## 2. 인증 페이지
```
파일: app/(auth)/login/page.tsx
기능: 이메일/비밀번호 로그인
```

## 3. 메인 페이지 (프로젝트 리스트)
```
파일: app/(main)/study/page.tsx
기능: 
- 프로젝트 카드 목록
- "새 프로젝트" 버튼
- 프로젝트 클릭 → 룸 리스트로 이동
```

## 4. 프로젝트 생성 모달
```
컴포넌트: features/study/components/CreateProjectModal.tsx
기능:
- 제목 입력
- 카테고리 선택
- 프롬프트 or 데이터 업로드
- AI 문제 생성 (OpenAI API)
```

---

# 중요 제약사항

❗ 절대 지킬 것:
1. Next.js App Router만 사용 (Pages Router 금지)
2. Server Component 우선 (Client는 필요시만 'use client')
3. Supabase RLS 반드시 활성화
4. TypeScript strict 모드
5. 모든 API 응답 Zod 검증
6. shadcn/ui 컴포넌트만 사용 (직접 만들기 금지)
7. 환경변수 .env.local에만 (커밋 금지)

❗ 하지 말 것:
1. localStorage/sessionStorage 사용 금지 (Zustand persist 사용)
2. fetch 직접 쓰지 말고 React Query 사용
3. CSS Modules/Styled Components 금지 (Tailwind만)
4. any 타입 금지
5. console.log 프로덕션 코드에 남기기 금지

---

# 코드 작성 시 항상 확인

매번 코드 작성 전 체크:
□ 이 컴포넌트는 Server Component인가 Client Component인가?
□ 타입이 명시되어 있는가?
□ Supabase RLS 정책이 적용되는가?
□ 에러 핸들링이 되어 있는가?
□ shadcn 컴포넌트를 재사용할 수 있는가?
□ 이 상태는 전역(Zustand)인가 로컬(useState)인가?
□ API 응답을 Zod로 검증했는가?

---


추가 사항 ->

# 추가 라이브러리

## PDF 처리
npm install pdf-parse
npm install react-dropzone

## 텍스트 처리
npm install @anthropic-ai/sdk  # Claude API (선택)

## 파일 업로드
npm install @supabase/storage-js  # Supabase Storage

🗄️ 데이터베이스 스키마 추가
sql-- 기존 projects 테이블에 컬럼 추가
ALTER TABLE projects ADD COLUMN IF NOT EXISTS
  original_content TEXT;  -- 원본 텍스트 전체

ALTER TABLE projects ADD COLUMN IF NOT EXISTS
  processed_content JSONB;  -- AI가 처리한 결과

ALTER TABLE projects ADD COLUMN IF NOT EXISTS
  file_url TEXT;  -- Supabase Storage URL (PDF 업로드 시)

-- 새 테이블: 원본 문장과 빈칸 매핑
CREATE TABLE content_segments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  original_sentence TEXT NOT NULL,  -- 원본 문장
  blank_version TEXT NOT NULL,      -- 빈칸 들어간 버전
  blanked_words JSONB NOT NULL,     -- 빈칸으로 만든 단어들
  segment_order INTEGER NOT NULL,   -- 순서
  difficulty TEXT,                  -- easy/medium/hard
  created_at TIMESTAMP DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_content_segments_project 
  ON content_segments(project_id);

🤖 AI 프롬프트 전략 (완전 개편)
1. 텍스트 분석 & 빈칸 생성 프롬프트
typescript// POST /api/ai/analyze-content

const analyzeContentPrompt = (content: string, settings: Settings) => `
당신은 교육 콘텐츠 전문가입니다. 
사용자가 제공한 학습 자료를 분석하고, 효과적인 빈칸 채우기 문제를 만드세요.

# 입력 자료
${content}

# 빈칸 생성 규칙
1. **중요도 기반 선택**
   - 핵심 개념, 용어, 숫자, 고유명사 우선
   - 문맥상 중요한 단어/구절
   - 학습 효과가 높은 부분

2. **난이도 조절**
   - Easy: 명확한 답이 있는 단어 (예: 고유명사, 숫자)
   - Medium: 문맥 파악 필요한 단어 (예: 동사, 형용사)
   - Hard: 추론 필요한 구절 (예: 개념 정의)

3. **빈칸 개수**
   - 문장당 1-2개 빈칸
   - 너무 많으면 문제가 모호해짐
   - 최소 문맥은 남겨둘 것

4. **다양성**
   - 다양한 유형의 단어 선택
   - 명사만 빈칸 ❌
   - 동사, 형용사, 숫자, 개념 등 골고루

# 출력 형식 (JSON만 반환)
{
  "segments": [
    {
      "original": "원본 문장 전체",
      "blank_version": "빈칸이 들어간 문장 (빈칸은 _____ 로 표시)",
      "blanked_words": [
        {
          "word": "빈칸으로 만든 단어",
          "position": 0,  // 문장에서 몇 번째 빈칸인지
          "hint": "힌트 (선택적)",
          "alternatives": ["유사 정답1", "유사 정답2"]  // 인정할 답변들
        }
      ],
      "difficulty": "easy" | "medium" | "hard",
      "explanation": "왜 이 단어가 중요한지",
      "order": 1
    }
  ],
  "summary": {
    "total_sentences": 50,
    "total_blanks": 75,
    "difficulty_distribution": {
      "easy": 30,
      "medium": 35,
      "hard": 10
    },
    "suggested_days": 5  // 추천 학습 일수
  }
}

# 예시

입력:
"React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. 
컴포넌트 기반 아키텍처를 사용하며, 가상 DOM을 통해 효율적인 렌더링을 제공합니다."

출력:
{
  "segments": [
    {
      "original": "React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다.",
      "blank_version": "_____는 사용자 인터페이스를 구축하기 위한 _____ 라이브러리입니다.",
      "blanked_words": [
        {
          "word": "React",
          "position": 0,
          "hint": "페이스북이 만든 프론트엔드 라이브러리",
          "alternatives": ["리액트"]
        },
        {
          "word": "JavaScript",
          "position": 1,
          "hint": "웹의 표준 프로그래밍 언어",
          "alternatives": ["자바스크립트", "JS"]
        }
      ],
      "difficulty": "easy",
      "explanation": "React와 JavaScript는 이 문장의 핵심 키워드",
      "order": 1
    },
    {
      "original": "컴포넌트 기반 아키텍처를 사용하며, 가상 DOM을 통해 효율적인 렌더링을 제공합니다.",
      "blank_version": "_____ 기반 아키텍처를 사용하며, _____ DOM을 통해 효율적인 렌더링을 제공합니다.",
      "blanked_words": [
        {
          "word": "컴포넌트",
          "position": 0,
          "hint": "UI를 재사용 가능한 단위로 나눈 것",
          "alternatives": ["component", "컴포넌트"]
        },
        {
          "word": "가상",
          "position": 1,
          "hint": "실제가 아닌 메모리 상의",
          "alternatives": ["Virtual", "버추얼"]
        }
      ],
      "difficulty": "medium",
      "explanation": "React의 핵심 개념들",
      "order": 2
    }
  ],
  "summary": {
    "total_sentences": 2,
    "total_blanks": 4,
    "difficulty_distribution": {
      "easy": 2,
      "medium": 2,
      "hard": 0
    },
    "suggested_days": 1
  }
}

이제 분석을 시작하세요.
`;

// 사용 예시
const response = await openai.chat.completions.create({
  model: "gpt-4o",
  messages: [
    {
      role: "system",
      content: "You are an expert educational content analyzer specializing in creating effective fill-in-the-blank exercises."
    },
    {
      role: "user",
      content: analyzeContentPrompt(userContent, settings)
    }
  ],
  response_format: { type: "json_object" },
  temperature: 0.7,
});

2. Day별 자동 분할 프롬프트
typescript// 이미 분석된 segments를 Day별로 나누기

const divideToDaysPrompt = (segments: Segment[], targetDays: number) => `
당신은 학습 커리큘럼 설계자입니다.
주어진 빈칸 문제들을 ${targetDays}일로 나누어 학습 계획을 세우세요.

# 입력 데이터
총 ${segments.length}개의 문제
난이도 분포: {easy: X, medium: Y, hard: Z}

# 분할 규칙
1. **난이도 균형**
   - 각 Day마다 쉬운/중간/어려운 문제 골고루
   - 앞쪽 Day는 쉬운 문제 비중 높게

2. **분량 조절**
   - 각 Day당 10-20문제 적정
   - 너무 적으면 학습 효과 ↓
   - 너무 많으면 부담 ↑

3. **연관성**
   - 같은 주제/개념은 같은 Day에
   - 순서가 중요한 내용은 순차적으로

4. **점진적 난이도**
   - Day 1: 주로 easy
   - Day 2-3: easy + medium
   - Day 4+: medium + hard

# 출력 형식 (JSON)
{
  "days": [
    {
      "day_number": 1,
      "title": "Day 1: {주제}",
      "segment_ids": [1, 2, 3, ...],  // 이 Day에 포함될 segment ID들
      "total_problems": 15,
      "difficulty_distribution": {
        "easy": 10,
        "medium": 5,
        "hard": 0
      },
      "estimated_time": 20  // 분
    }
  ]
}
`;